# 2.1

## 2.1.2 What is the maximum number of exchanges involving any particular item during selection sort? What is the average number of exchanges involving an item?

Since evry loop get the smallest value after the index n, so we just put a huge number before an ordered list, so it has to change n-1 times for a n-length list.

e.g.

> 10 1 2 3 4 5 6 7 8 9

## 2.1.5 for each of the two conditions in the inner for loop in insertion sort, descirbe an array of _N_ items where that condition is always false when the loop terminates.

this will work:

> 1 9 8 7 6 5 4 3 2

## 2.1.6  Which method runs fastest for an array with all keys identical, selection sort or insertion sort?

Insertion sort is faster.

## 2.1.7  Which method runs fastest for an array in reverse order, selection sort or insertion sort?

Insertion sort is slower, because they compare the same amount of pairs, but insertion sort exchange more.

## 2.1.8 Suppose that we use insertion sort on a randomly ordered array where items have only one of three key values. Is the running time linear, quadratic, or something in between?

still time quadratic

## 2.1.10 Why not use selection sort for h-sorting in shellsort?

As descripted in this section, insertion sort works well for partially sorted array.

## 2.1.11 Implement a version of shellsort that keeps the increment sequence in an array, rather than computing it.

```python
n = len(items)
seq = [1, 4, 13, 40, ...]
step = 1
for i in xrange(1000):
    if seq[i] > n:
       step = i
       break
# continue shell sort       
```

## 