# 关于如何刷题

## 总则
先抛开具体使用的算法不谈，刷 leetcode、各种面试的经验就是： “如何在题目与前提条件之间找到一条沟通的桥梁”。这里面有三点至关重要：

* 是否应用了全部的已知条件
* 是否“只”做了题目要求的工作、计算
* 槽猛快

### 应用全部已知条件
一般来说，这点都会注意到，比如“原来给的是一个有序的列表”、“数据最大、最小不超过 N”， 这种明确写出的条件，一般对选择后续的算法，有决定性作用。

### "只“做题目要求的工作
这一点在刷题时作用更大，比如：
* 取一个列表的第 K 大的值，这时候就不需要将全部列表排序（甚至不需要排序前面 K 个元素）
* 一堆桶中取出当前最大的元素，只需要维护当前拿到的是最大、最小元素即可
* 选取非常多的元素中的 top N 个值

前面的例子是计算资源上的避免无用功，在空间上同样有这个原则： 
* 涉及到缓存的，只保留后续需要使用的中间结果（动态规划 vs 缓存）
* 找出某个/些具体元素的，不用保留全部的历史

遇到一个题目，如果你的解决方案中，计算、存储涉及到了题目没有要求的部分，就需要考虑下是不是违反了这个原则

### 槽猛快
无论是实际工作，还是刷题，下面这个原则都非常有效：

__在 N 非常小的时候，使用原始、下意识的解决方案，是最优选择__

它有几个优点：
* 编写速度快
* 相比更快速的算法，需要处理的 edge case 很小，程序很容易一次通过

有几个场景可以参考：
* 快排只剩三个元素的时候，
* 查找只剩下 100 个 item 的时候
* 各种查找的暴力算法

## 完美主义倾向

我把它单独写出来，因为我在这上面走了很多弯路；总想把代码写“好”的话，会让自己容易挫败，并且进度缓慢。类似于做工程，我们应该遵循三个步骤：

* 把它上线
* 把它做对
* 把它做好

这三个步骤，在刷题的时候也是一样，思路出来，先写一版试试，细节可以一边写一边想，不要在一开始就想怎么处理 edge case。一个使用 for 循环写出来的冒泡排序只要能解决问题，它就是一段好的程序。

## 常用数据结构与算法

在熟练使用、选择各种数据结构之前，需要参考教科书熟练掌握各种算法的时间、空间复杂度。
下面列举一些常用算法，以及他们的适用场景

### 堆
按照我的经验，堆是在面试、刷题过程中，最重要的数据结构。它能够在非常小的时间消耗下，来维护一个有序的的集合。例如：
* merge sort 时如何取下一个 item
* 如何从一个 stream 中取得 top N 的元素
* 如何实现一个 LRU 的 cache

### 快排
快排应该是大家非常喜欢考的算法，然后网上流传的算法，都比较晦涩。这里推荐 《算法》第四版中的实现，易懂易写。对于快排，重要的不是它能够排序，而是这种分治的思路，能够简化非常复杂的问题，使复杂度降低为 O(logN). 常见的场景有：

* 排序
* 取第 N 个元素

### cache vs DP
从我们以前的工作经验出发，我们很容易在各种场景使用 cache；唯一需要考虑的是空间复杂度，如何只缓存必要的结果，不出现 OOM。DP 同样是能够利用旧的结果来产生新的方案，判断两者的方式是：对于这些旧结果，我们能不能做到只使用它一次；如果可以，用 DP；不可以则使用普通的 cache。

### 递归

递归是我最喜欢使用的方式，它能够快速的完成对题目的抽象，大幅缩短代码。使用递归可以方便得实现各种算法，但是它的缺陷是：
* 如果使用错误，会忘记在哪跳出
* 时间、空间容易很差

对第一个问题，需要理清逻辑，避免出现错误；第二个问题，需要考虑好在哪剪枝，以及合理使用缓存。一般我遇到问题，只要能使用递归的我都会使用它，快速写出代码，然后找可以优化的点，提高时间、空间上的表现。

### 暴力

这种方式刷题不一定通过，但是面试的时候，如果没有更好的办法，暴力出一版结果总比没有好，又不是不能用。

### 一些数学知识

* 位运算
* Matrix

位运算有事可以大幅提升运算效率，而矩阵在计算迭代的过城中，可以吧 O(n) 的问题变成 O(log N),比如在某些数列的运算上。这些能想到最好，不想到一般不会做为 blocker 出现，不用强求。在很多场景需要非常强的数学功底，这些是需要磨练，也不能短期提高，可以做为长期的计划来学习。

